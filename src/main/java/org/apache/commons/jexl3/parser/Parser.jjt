/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


options
{
   MULTI=true;
   STATIC=false;
   JAVA_TEMPLATE_TYPE="modern";
   VISITOR=true;
   NODE_SCOPE_HOOK=true;
   NODE_CLASS="JexlNode";
   UNICODE_INPUT=true;
   KEEP_LINE_COLUMN=true;
   TRACK_TOKENS=true;
   CACHE_TOKENS=true;
   ERROR_REPORTING=false;
   //DEBUG_PARSER=true;
   //DEBUG_TOKEN_MANAGER=true;
}

PARSER_BEGIN(Parser)

package org.apache.commons.jexl3.parser;

import java.util.Collections;
import java.util.Collection;
import java.util.Map;
import java.util.LinkedList;
import java.util.LinkedHashSet;
import java.util.regex.Pattern;

import org.apache.commons.jexl3.JexlInfo;
import org.apache.commons.jexl3.JexlFeatures;
import org.apache.commons.jexl3.JexlOptions;
import org.apache.commons.jexl3.JexlException;
import org.apache.commons.jexl3.internal.Scope;

public final class Parser extends JexlParser
{
    public ASTJexlScript parse(JexlInfo jexlInfo, JexlFeatures jexlFeatures, JexlOptions jexlOptions, String jexlSrc, Scope jexlScope) {
        JexlFeatures previous = getFeatures();
        try {
            setFeatures(jexlFeatures);
            // lets do the 'Unique Init' in here to be safe - it's a pain to remember
            info = jexlInfo != null? jexlInfo : new JexlInfo();
            source = jexlSrc;
            pragmas = null;
            implicitPackages = new LinkedHashSet(jexlOptions.getImports());
            scope = jexlScope;
            branchScope = new BranchScope();
            ReInit(jexlSrc);
            ASTJexlScript script = jexlFeatures.supportsScript()? JexlScript(jexlScope) : JexlExpression(jexlScope);
            script.jjtSetValue(info.detach());
            script.setFeatures(jexlFeatures);
            script.setPragmas(pragmas != null
                             ? Collections.unmodifiableMap(pragmas)
                             : Collections.emptyMap());
            return script;
        } catch (TokenMgrException xtme) {
            throw new JexlException.Tokenization(info, xtme).clean();
        } catch (ParseException xparse) {
            Token errortok = errorToken(jj_lastpos, jj_scanpos, token.next, token);
            throw new JexlException.Parsing(info.at(errortok.beginLine, errortok.beginColumn), errortok.image).clean();
        } finally {
            token_source.defaultLexState = DEFAULT;
            cleanup(previous);
            jjtree.reset();
        }
    }
}

PARSER_END(Parser)

TOKEN_MGR_DECLS : {}

/***************************************
 *     Skip & Number literal tokens
 ***************************************/

<*> SKIP : /* WHITE SPACE */
{
      " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"
    | "\u00A0"
    | <"##" (~["\n","\r"])* ("\n" | "\r" | "\r\n")? >
    | <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
    | <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")? >
}

<*> TOKEN : { /* SEPARATORS */
      < LPAREN : "(" > : DEFAULT
    | < RPAREN : ")" > : DEFAULT
    | < LCURLY : "{" >
    | < RCURLY : "}" >
    | < LBRACKET : "[" > : DEFAULT
    | < RBRACKET : "]" > : DEFAULT
    | < SEMICOL : ";" >
    | < COLON : ":" >
    | < DCOLON : "::" >
    | < COMMA : "," >
    | < DOT : "." > : DOT_ID
    | < QDOT : "?." > : DOT_ID
    | < DOTAT : ".@" > : DOT_ID
    | < QLBRACKET : "?[" >
    | < ELLIPSIS : "..." | "\u2026">
    | < HBRACKET : "#[" >
    | < HCURLY : "#{" >
}

<DEFAULT, QUALIFIED> TOKEN : { /* PRIMITIVE TYPES */
      < INT :     "int" > : DEFAULT
    | < CHAR :    "char" > : DEFAULT
    | < BYTE :    "byte" > : DEFAULT
    | < VOID :    "void" > : DEFAULT
    | < LONG :    "long" > : DEFAULT
    | < SHORT :   "short" > : DEFAULT
    | < FLOAT :   "float" > : DEFAULT
    | < DOUBLE :  "double" > : DEFAULT
    | < BOOLEAN : "boolean" > : DEFAULT
}

<*> TOKEN : { /* STREAMS */
      < DOTP : ".(" >
    | < DOTB : ".[" >
    | < DOTC : ".{" >
}

<*> TOKEN : { /* CONDITIONALS */
      < QMARK : "?" >
    | < ELVIS : "?:" >
    | < EN_ASSIGN : "=:" >
    | < NULLP : "??" >
    | < AND : "&&" | "\u2227" >
    | < OR : "||" | "\u2228" >
}

<DEFAULT> TOKEN : { /* CONDITIONALS */
      < _AND :  "and" >
    | < _OR: "or" >
}

<*> TOKEN : { /* COMPARISONS */
      < eq : "==" | "\u2261">
    | < ne : "!=" | "\u2260" >
    | < req : "=~" | "\u2208" > // regexp equal
    | < rne : "!~" | "!in" | "\u2209" > // regexp not equal
    | < is : "===" > // identitical
    | < ni : "!==" > // not identitical
    | < seq : "=^" > // starts equal
    | < eeq : "=$" > // ends equal
    | < sne : "!^" > // start not equal
    | < ene : "!$" > // ends not equal
    | < gt : ">" >
    | < ge : ">=" | "\u2265" >
    | < lt : "<" >
    | < le : "<=" | "\u2264" >
}

<DEFAULT> TOKEN : { /* COMPARISONS */
      < EQ : "eq" >
    | < NE : "ne" >
    | < IN : "in" >
    | < GT : "gt" >
    | < GE : "ge" >
    | < LT : "lt" >
    | < LE : "le" >
    | < iof : "instanceof" > : QUALIFIED
    | < niof : "!instanceof" > : QUALIFIED
}

<*> TOKEN : { /* OPERATORS */
      < assign : "=" >
    | < plus_assign : "+=" >
    | < minus_assign : "-=" >
    | < mult_assign : "*=" >
    | < div_assign : "/=" >
    | < mod_assign : "%=" >
    | < and_assign : "&=" >
    | < or_assign : "|=" >
    | < xor_assign : "^=" >
    | < null_assign : "?=" >
    | < ne_assign : ":=" >
    | < increment : "++" >
    | < decrement : "--" >
    | < tilda : "~" >
    | < plus : "+" >
    | < minus : "-" >
    | < unary_minus : "\u2212" >
    | < mult : "*" | "\u22C5" >
    | < div : "/" >
    | < mod : "%" >
    | < not : "!" | "\u00AC" >
    | < and : "&" >
    | < or : "|" >
    | < xor : "^" >
    | < range : ".." | "\u2025" >
    | < lshift : "<<" >
    | < rshift : ">>" >
    | < rshiftu : ">>>" >
    | < lshift_assign : "<<=" >
    | < rshift_assign : ">>=" >
    | < rshiftu_assign : ">>>=" >
}

<DEFAULT> TOKEN : { /* OPERATORS */
      < DIV : "div" >
    | < MOD : "mod" >
    | < NOT : "not" >
}

<*> TOKEN : /* KEYWORDS */
{
      < LAMBDA : "->" | "\u2192" > 
    | < FATARROW : "=>" >
    | < NEW : "new" > : QUALIFIED 
    | < PRAGMA : "#pragma" > : QUALIFIED
    | < CLASS : "class" >
}

<DEFAULT> TOKEN : /* KEYWORDS */
{
      < UNDERSCORE : "_" > 
    | < IF : "if" > 
    | < DO : "do" > 
    | < FOR : "for" > 
    | < TRY : "try" > 
    | < VAR : "var" >
    | < LET : "let" >
    | < CASE : "case" > 
    | < ELSE : "else" > 
    | < SIZE : "size" >
    | < THIS : "this" >
    | < NULL : "null" | "\u2205" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < WHILE : "while" > 
    | < CATCH : "catch" > 
    | < THROW : "throw" > 
    | < CONST : "const" >
    | < FINAL : "final" >
    | < EMPTY : "empty" >
    | < YIELD : "yield" >
    | < BREAK : "break" >
    | < ASSERT : "assert" > 
    | < SWITCH : "switch" > 
    | < REMOVE : "remove" >
    | < RETURN : "return" >
    | < STATIC : "static" >
    | < DCASE : "default" > 
    | < FINALLY : "finally" > 
    | < FUNCTION : "function" >
    | < CONTINUE : "continue" >
    | < SYNCHRONIZED : "synchronized" > 
}

/***************************************
 *     Identifier & String tokens
 ***************************************/
<DEFAULT> TOKEN :  /* NaN */
{
    < NAN_LITERAL : "NaN" >
}

<DEFAULT> TOKEN : /* ANNOTATION */
{
  < ANNOTATION: "@" ( [ "0"-"9", "a"-"z", "A"-"Z", "_", "$" ])+ >
}

<DEFAULT,DOT_ID> TOKEN : /* CURRENT CONTEXT */
{
  < CURRENT: "@" > : DEFAULT
}

<DOT_ID> TOKEN : /* IDENTIFIERS */
{
  < DOT_IDENTIFIER: ( [ "0"-"9", "a"-"z", "A"-"Z", "_", "$", "@" ])+ > : DEFAULT
}

<DEFAULT> TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|<ESCAPE>)* > { matchedToken.image = StringParser.unescapeIdentifier(matchedToken.image); }
  |
  < #LETTER: [ "a"-"z", "A"-"Z", "_", "$", "@" ] >
  |
  < #DIGIT: [ "0"-"9"] >
  |
  < #ESCAPE: "\\" [" ", "'", "\"", "\\"] >
}

<QUALIFIED> TOKEN : /* IDENTIFIERS */
{
  < QUALIFIED_IDENTIFIER: <QNAME> ("." <QNAME>)* > : DEFAULT
  |
  < #QNAME: [ "a"-"z", "A"-"Z", "_", "$", "@" ] ([ "a"-"z", "A"-"Z", "_", "$", "@", "0"-"9" ])* >
}

<DEFAULT> TOKEN :
{
  < REGISTER: "#" (["0"-"9"])+ >
}

<DEFAULT> TOKEN : /* LITERALS */
{
  <INTEGER_LITERAL:
      <DECIMAL_LITERAL> (<INT_SFX>)?
    | <HEX_LITERAL> (<INT_SFX>)?
    | <OCTAL_LITERAL> (<INT_SFX>)?
    | <BINARY_LITERAL> (<INT_SFX>)?
  >
    | <#DECIMAL_LITERAL: ["1"-"9"] ((["0"-"9","_"])* <DIGIT> | (<DIGIT>)*) >
    | <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"] (["0"-"9","a"-"f","A"-"F","_"])* ["0"-"9","a"-"f","A"-"F"] | (["0"-"9","a"-"f","A"-"F"])+) >
    | <#BINARY_LITERAL: "0" ["b","B"] (["0"-"1"] (["0"-"1","_"])* ["0"-"1"] | (["0"-"1"])+) >
    | <#OCTAL_LITERAL: "0" ((["0"-"7","_"])* ["0"-"7"] | (["0"-"7"])*) >
    | <#INT_SFX : ["l","L","h","H"]>
  |
  <FLOAT_LITERAL:
      <FLT_NUM> "." <FLT_NUM> (<FLT_SFX>)?
    | <FLT_NUM> (".")? (<FLT_SFX>)
    | "." <FLT_NUM> (<FLT_SFX>)
    | "#NaN"
  >
    |  <#FLT_NUM: (<DIGIT> (["0"-"9","_"])* <DIGIT> | (<DIGIT>)+) >
    |  <#EXPONENT: ["e","E"] (["+","-"])? <FLT_NUM> >
    |  <#FLT_CLS : ["f","F","d","D","b","B"]>
    |  <#FLT_SFX : <EXPONENT> (<FLT_CLS>)? | <FLT_CLS> >
}

<*> TOKEN :
{
  < STRING_LITERAL:
    "\"" (~["\"","\\","\n","\r","\u2028","\u2029"] | "\\" ~["\n","\r","\u2028","\u2029"])* "\""
    |
    "\u201C" (~["\u201C","\u201D","\\","\n","\r","\u2028","\u2029"] | "\\" ~["\n","\r","\u2028","\u2029"])* "\u201D"
    |
    "\u2018" (~["\u2018","\u2019","\\","\n","\r","\u2028","\u2029"] | "\\" ~["\n","\r","\u2028","\u2029"])* "\u2019"
    |
    "'" (~["'","\\","\n","\r","\u2028","\u2029"] | "\\" ~["\n","\r","\u2028","\u2029"])* "'"
  > : DEFAULT
}

<*> TOKEN :
{
  < JXLT_LITERAL:
    "`" (~["`","\\"] | "\\" ~["\u0000"])* "`"
  > : DEFAULT
}

<DEFAULT> TOKEN :
{
  < REGEX_LITERAL:
    "~" "/" (~["/","\n","\r","\u2028","\u2029"] | "\\" "/" )* "/"
  >
}

<*> TOKEN :
{
  < BLOCK_LITERAL:
    "\"\"\"" ([" ","\t"])* ("\n" | "\r" | "\r\n") ("\\" "\"" | ~[])* "\"\"\""
  > : DEFAULT
}

/***************************************
 *      Statements
 ***************************************/

ASTJexlScript JexlScript(Scope scope) :
{
    jjtThis.setScope(scope);
    pushUnit(jjtThis);
}
{
    (LOOKAHEAD(<PRAGMA>) Pragma())*
    (
       LOOKAHEAD( LambdaLookahead() ) Lambda() [ <SEMICOL> ]
       |
       (GenericStatement())*
    ) <EOF>
{
    popUnit(jjtThis);
    jjtThis.setScope(getScope());
    popScope();
    return jjtThis.script();
}
}

ASTJexlScript JexlExpression(Scope scope) #JexlScript :
{
    jjtThis.setScope(scope);
    pushUnit(jjtThis);
}
{
    [ Expression() ] <EOF>
{
    popUnit(jjtThis);
    jjtThis.setScope(getScope());
    popScope();
    return jjtThis.script();
}
}

void Annotation() #Annotation :
{
    Token t;
}
{
    t=<ANNOTATION> (LOOKAHEAD(<LPAREN>) Arguments() )? { jjtThis.setName(t.image); }
}

void AnnotatedStatement() #AnnotatedStatement : {}
{
    (LOOKAHEAD(<ANNOTATION>) Annotation())+ (LOOKAHEAD({!getFeatures().isLexical()}) GenericStatement() | Statement())
}

void GenericStatement() #void : {}
{
    <SEMICOL>
    | AnnotatedStatement()
    | LOOKAHEAD(FunctionStatementLookahead()) FunctionStatement()
    | LOOKAHEAD(LabelledStatementLookahead()) LabelledStatement()
    | LOOKAHEAD(DeclareLocalVar()) VarStatement()
    | LOOKAHEAD(SwitchStatementLookahead()) SwitchStatement()
    | LOOKAHEAD(Expression()) ExpressionStatement()
    | Block()
    | IfStatement()
    | LOOKAHEAD(<FOR> <LPAREN> ForeachVar() <COLON>) ForeachStatement()
    | ForStatement()
    | WhileStatement()
    | DoWhileStatement()
    | LOOKAHEAD(<TRY> <LPAREN>) TryWithResourceStatement()
    | TryStatement()
    | ThrowStatement()
    | AssertStatement()
    | SynchronizedStatement()
    | LOOKAHEAD(MultipleIdentifier() <assign>) MultipleAssignmentStatement()
    | ReturnStatement()
    | YieldStatement()
    | Continue()
    | Remove()
    | Break()
    | LOOKAHEAD(<VAR> <LPAREN> | <FINAL> <VAR> <LPAREN>) MultipleVarStatement()
}

void Statement() #void : {}
{
    <SEMICOL>
    | AnnotatedStatement()
    | LOOKAHEAD(LabelledStatementLookahead()) LabelledStatement()
    | LOOKAHEAD(SwitchStatementLookahead()) SwitchStatement()
    | LOOKAHEAD(Expression()) ExpressionStatement()
    | Block()
    | IfStatement()
    | LOOKAHEAD(<FOR> <LPAREN> ForeachVar() <COLON>) ForeachStatement()
    | ForStatement()
    | WhileStatement()
    | DoWhileStatement()
    | LOOKAHEAD(<TRY> <LPAREN>) TryWithResourceStatement()
    | TryStatement()
    | ThrowStatement()
    | AssertStatement()
    | SynchronizedStatement()
    | LOOKAHEAD(MultipleIdentifier() <assign>) MultipleAssignmentStatement()
    | ReturnStatement()
    | YieldStatement()
    | Continue()
    | Remove()
    | Break()
}

void StatementBranch() #void : {}
{
    LOOKAHEAD(1) Block() | LOOKAHEAD({!getFeatures().isLexical()}) GenericStatement() | Statement()
}

void LabelledStatementLookahead() #void : {}
{
    <IDENTIFIER> <COLON> ( <LCURLY> | <IF> | <FOR> | <WHILE> | <DO> | <SWITCH> | <SYNCHRONIZED> | <TRY>)
}

void LabelledStatement() #void :
{
    Token t = null;
    String label = null;
    ASTLabelledStatement s;
}
{
    t=<IDENTIFIER> { label = t.image; if (branchScope.breakSupported(label)) throwParsingException(t); } <COLON>
    (
        LOOKAHEAD(<LCURLY>) { branchScope.pushBlockLabel(label); } s = Block() { s.setLabel(label); branchScope.popBlockLabel(); }
        |
        LOOKAHEAD(<FOR> <LPAREN> ForeachVar() <COLON>) { branchScope.pushForeachLabel(label); } s = ForeachStatement() { s.setLabel(label); branchScope.popForeachLabel(); }
        |
        { branchScope.pushLoopLabel(label); } s = ForStatement() { s.setLabel(label); branchScope.popLoopLabel(); }
        |
        { branchScope.pushLoopLabel(label); } s = WhileStatement() { s.setLabel(label); branchScope.popLoopLabel(); }
        |
        { branchScope.pushLoopLabel(label); } s = DoWhileStatement() { s.setLabel(label); branchScope.popLoopLabel(); }
        |
        { branchScope.pushBlockLabel(label); } s = SwitchStatement() { s.setLabel(label); branchScope.popBlockLabel(); }
        |
        { branchScope.pushBlockLabel(label); } s = IfStatement() { s.setLabel(label); branchScope.popBlockLabel(); }
        |
        { branchScope.pushBlockLabel(label); } s = SynchronizedStatement() { s.setLabel(label); branchScope.popBlockLabel(); }
        |
        LOOKAHEAD(<TRY> <LPAREN>) { branchScope.pushBlockLabel(label); } s = TryWithResourceStatement() { s.setLabel(label); branchScope.popBlockLabel(); }
        |
        { branchScope.pushBlockLabel(label); } s = TryStatement() { s.setLabel(label); branchScope.popBlockLabel(); }
    )
}

ASTBlock Block() #Block :
{
    pushUnit(jjtThis);
}
{
    <LCURLY> (GenericStatement())* <RCURLY>
{
    popUnit(jjtThis);
    return jjtThis;
}
}

void ExpressionStatement() : {}
{
    Expression() (LOOKAHEAD(Expression()) Expression() #Ambiguous(1))* (LOOKAHEAD(1) <SEMICOL>)?
}

void MultipleAssignmentStatement() #MultipleAssignment : {}
{
    MultipleIdentifier() <assign> Expression()
}

void MultipleIdentifier() #MultipleIdentifier : {}
{
    <LPAREN> AssignmentIdentifier() (<COMMA> AssignmentIdentifier())* <RPAREN>
}

void AssignmentIdentifier() #void : {}
{
    UnderscoreLiteral()
    |
    Identifier(true)
}

void FunctionStatementLookahead() #void : {}
{
    [ <STATIC> ] (<FUNCTION> | FunctionType()) FunctionVar() <LPAREN>
}

void FunctionStatement() :
{
    boolean isStatic = false;
    Class type = null;
}
{
    [ <STATIC> { isStatic = true; } ] (<FUNCTION> | type = FunctionType()) FunctionVar() Function(isStatic, type)
}

Class FunctionType() #void :
{
    Token t;
    Token te;
    Class type = null;
}
{
    (
       t=<VOID> { type = Void.TYPE; }
       |
       (
         t=<INT> { type = Integer.TYPE; }
         |
         t=<LONG> { type = Long.TYPE; }
         |
         t=<SHORT> { type = Short.TYPE; }
         |
         t=<BYTE> { type = Byte.TYPE; }
         |
         t=<CHAR> { type = Character.TYPE; }
         |
         t=<BOOLEAN> { type = Boolean.TYPE; }
         |
         t=<FLOAT> { type = Float.TYPE; }
         |
         t=<DOUBLE> { type = Double.TYPE; }
         |
         LOOKAHEAD( { getToken(1).kind == IDENTIFIER && resolveType(getToken(1).image) != null } ) 
         t=<IDENTIFIER> { type = resolveType(t.image); }
         ( LOOKAHEAD(2) <DOT> te=<DOT_IDENTIFIER> { type = resolveNestedType(type, te.image); if (type == null) throwParsingException(te); } )*
       )
       ( LOOKAHEAD( <LBRACKET> ) <LBRACKET> <RBRACKET> { type = JexlParser.arrayType(type); })*
    )
{
    return type;
}
}

void FunctionVar() :
{
    Token t;
}
{
    t=<IDENTIFIER> 
{
    jjtThis.setConstant(true); 
    declareVariable(jjtThis, t); 
}
}

void Function(boolean isStatic, Class type) #JexlLambda :
{
    pushScope();
    pushUnit(jjtThis);
    if (isStatic) declareStaticSupport();
    if (type != null) declareReturnType(type);
}
{
    Parameters() ( Block() | ( <LAMBDA> | <FATARROW> ) Expression() )
{
    popUnit(jjtThis);
    jjtThis.setScope(scope);
    popScope();
}
}

void ExpressionLambda() #SimpleLambda :
{
    pushScope();
    pushUnit(jjtThis);
}
{
    ConditionalExpression()
{
    popUnit(jjtThis);
    jjtThis.setScope(scope);
    popScope();
}
}

ASTIfStatement IfStatement() : {}
{
    <IF> <LPAREN> Expression() <RPAREN> StatementBranch()
    [ LOOKAHEAD(1) <ELSE> StatementBranch() ]
{
    return jjtThis;
}
}

ASTWhileStatement WhileStatement() : {}
{
    <WHILE> <LPAREN> Expression() <RPAREN>  { branchScope.loopCount += 1; } StatementBranch() { branchScope.loopCount -= 1; }
{
    return jjtThis;
}
}

ASTDoWhileStatement DoWhileStatement() : {}
{
    <DO> { branchScope.loopCount += 1; } StatementBranch() <WHILE> <LPAREN> Expression() <RPAREN> { branchScope.loopCount -= 1; }
{
    return jjtThis;
}
}

ASTTryStatement TryStatement() :
{
    branchScope.yieldReturnCount -= 1;
}
{
    <TRY> Block()
    (
        (CatchBlock())+ [ <FINALLY> Block() ]
        |
        <FINALLY> Block()
    )
{
    branchScope.yieldReturnCount += 1;
    return jjtThis;
}
}

ASTTryWithResourceStatement TryWithResourceStatement() :
{
    pushUnit(jjtThis);
    branchScope.yieldReturnCount -= 1;
}
{
    <TRY> <LPAREN> TryResource() <RPAREN> ( LOOKAHEAD(InlinePropertyAssignment()) InlinePropertyAssignment() | Block())
    {
      popUnit(jjtThis);
    }
    (CatchBlock())* [ <FINALLY> Block() ]
{
    branchScope.yieldReturnCount += 1;
    return jjtThis;
}
}

void CatchBlock() :
{
    pushUnit(jjtThis);
}
{
    <CATCH> [ <LPAREN> CatchVar() <RPAREN> ] Block()
{
    popUnit(jjtThis);
}
}

void TryResource() : {}
{
    LOOKAHEAD(TryVar() <assign>) TryVar() <assign> Expression()
    |
    Expression()
}

void TryVar() : {}
{
    DeclareTryVar()
    |
    Identifier(true)
}

void CatchVar() #void : {}
{
    DeclareMultiCatchVar()
    |
    DeclareCatchVar()
    |
    Identifier(true)
}

void ThrowStatement() : {}
{
    <THROW> Expression()
}

void AssertStatement() : {}
{
    <ASSERT> Expression() [ <COLON> Expression() ]
}

ASTSynchronizedStatement SynchronizedStatement() :
{
    branchScope.yieldReturnCount -= 1;
}
{
    <SYNCHRONIZED> <LPAREN> Expression() <RPAREN> Block()
{
    branchScope.yieldReturnCount += 1;
    return jjtThis;
}
}

void SwitchStatementLookahead() : {}
{
    <SWITCH> <LPAREN> Expression() <RPAREN> <LCURLY> (<CASE> SwitchCaseLabel() | <DCASE>) <COLON>
}

ASTSwitchStatement SwitchStatement() :
{
    pushUnit(jjtThis);
}
{
    <SWITCH> <LPAREN> Expression() <RPAREN> { branchScope.switchCount += 1; } <LCURLY> SwitchStatementBlock() <RCURLY> { branchScope.switchCount -= 1; }
{
    popUnit(jjtThis);
    return jjtThis;
}
}

void SwitchStatementBlock() #void : {}
{
    SwitchStatementCase() (LOOKAHEAD(SwitchStatementBlock()) SwitchStatementBlock())*
    |
    SwitchStatementDefault() (LOOKAHEAD(SwitchStatementCase()) SwitchStatementCase())*
}

void SwitchStatementCase() : {}
{
    <CASE> SwitchCaseLabel() <COLON> (GenericStatement())*
}

void SwitchStatementDefault() : {}
{
    <DCASE> <COLON> (GenericStatement())*
}

void ReturnStatement() : {}
{
    <RETURN> LOOKAHEAD( {!isDeclaredVoid()} ) ( [ LOOKAHEAD(2) ExpressionStatement() ] { if (branchScope.yieldSupported()) { throwParsingException(jjtThis); } } )
}

void YieldStatement() : {}
{
    <YIELD> Expression() { if (!branchScope.yieldSupported()) { throwParsingException(jjtThis); }; if (branchScope.yieldCount == 0) jjtThis.setReturn(); }
}

void Continue() #Continue :
{
    Token t = null;
}
{
    <CONTINUE> [ LOOKAHEAD(<IDENTIFIER>) t = <IDENTIFIER> { if (!branchScope.continueSupported(t.image)) throwParsingException(jjtThis); jjtThis.setLabel(t.image); } ]
    { if (t == null && !branchScope.continueSupported()) { throwParsingException(jjtThis); } }
}

void Remove() #Remove :
{
    Token t = null;
}
{
    <REMOVE> [ LOOKAHEAD(<IDENTIFIER>) t = <IDENTIFIER> { if (!branchScope.removeSupported(t.image)) throwParsingException(jjtThis); jjtThis.setLabel(t.image); } ]
    { if (t == null && !branchScope.removeSupported()) { throwParsingException(jjtThis); } }
}

void Break() #Break :
{
    Token t = null;
}
{
    <BREAK> [ LOOKAHEAD(<IDENTIFIER>) t = <IDENTIFIER> { if (!branchScope.breakSupported(t.image)) throwParsingException(jjtThis); jjtThis.setLabel(t.image); } ]
    { if (t == null && !branchScope.breakSupported()) { throwParsingException(jjtThis); } }
}

ASTForStatement ForStatement() :
{
    pushUnit(jjtThis);
}
{
    <FOR> <LPAREN> ForInitializationNode() <SEMICOL> ForTerminationNode() <SEMICOL> ForIncrementNode() <RPAREN> { branchScope.loopCount += 1; } StatementBranch() { branchScope.loopCount -= 1; }
{
    popUnit(jjtThis);
    return jjtThis;
}
}

void ForInitializationNode() : {}
{
    [ ForInitializationExpression() (<COMMA> ForInitializationExpression() )* ]
}

void ForInitializationExpression() #void : {}
{
    LOOKAHEAD(DeclareLocalVar()) VarStatement() | Expression()
}

void ForTerminationNode() : {}
{
    [ ConditionalExpression() ]
}

void ForIncrementNode() : {}
{
    [ Expression() (<COMMA> Expression())* ]
}

ASTForeachStatement ForeachStatement() :
{
    pushUnit(jjtThis);
}
{
    <FOR> <LPAREN> ForeachVar() <COLON> Expression() <RPAREN> { branchScope.foreachLoopCount += 1; } StatementBranch() { branchScope.foreachLoopCount -= 1; }
{
    popUnit(jjtThis);
    return jjtThis;
}
}

void ForeachVar() :
{
    ASTVar var;
}
{
    LOOKAHEAD(2) var = DeclareVar() [ <COMMA> DeclareExtVar(var.isLexical(), var.isConstant(), null) ]
    |
    LOOKAHEAD(DeclareForVar()) DeclareForVar()
    |
    Identifier(true) [ <COMMA> Identifier(true) ]
}

ASTVar DeclareVar() #Var :
{
    Token t;
}
{
    (
        <LET> { jjtThis.setLexical(true); } t=<IDENTIFIER> 
        |
        <CONST> { jjtThis.setLexical(true); jjtThis.setConstant(true); } t=<IDENTIFIER> 
        |
        [ <FINAL> { jjtThis.setConstant(true); } ] <VAR> t=<IDENTIFIER> 
    )
{
    declareVariable(jjtThis, t);
    return jjtThis;
}
}

ASTVar DeclareExtVar(boolean lexical, boolean constant, Class type) #ExtVar :
{
    Token t;
    if (constant) jjtThis.setConstant(true);
    if (lexical) jjtThis.setLexical(true);
    if (type != null) jjtThis.setType(type);
}
{
    [ <and> { jjtThis.setRequired(); } ] t=<IDENTIFIER>
{
    declareVariable(jjtThis, t);
    return jjtThis;
}
}

void DeclareForVar() #Var :
{
    Token t;
    Token te;
    Class type;
}
{
    [ <FINAL> { jjtThis.setConstant(true); } ]
    ( <INT> { jjtThis.setType(Integer.TYPE); }
      |
      <LONG> { jjtThis.setType(Long.TYPE); }
      |
      <SHORT> { jjtThis.setType(Short.TYPE); }
      |
      <BYTE> { jjtThis.setType(Byte.TYPE); }
      |
      <CHAR> { jjtThis.setType(Character.TYPE); }
      |
      <BOOLEAN> { jjtThis.setType(Boolean.TYPE); }
      |
      <FLOAT> { jjtThis.setType(Float.TYPE); }
      |
      <DOUBLE> { jjtThis.setType(Double.TYPE); }
      |
      LOOKAHEAD( { getToken(1).kind == IDENTIFIER && resolveType(getToken(1).image) != null } ) 
      t=<IDENTIFIER> { jjtThis.setType(resolveType(t.image)); }
      ( LOOKAHEAD(2) <DOT> te=<DOT_IDENTIFIER> { type = resolveNestedType(jjtThis.getType(), te.image); if (type == null) throwParsingException(jjtThis); jjtThis.setType(type); } )*
    ) 
    (<LBRACKET> <RBRACKET> { jjtThis.setArray(); } )*
    t=<IDENTIFIER> 
{ 
    declareVariable(jjtThis, t); 
}
}

ASTVar DeclareLocalVar() #Var :
{
    Token t;
    Token te;
    Class type;
}
{
    (
        <LET> { jjtThis.setLexical(true); }
        |
        <CONST> { jjtThis.setLexical(true); jjtThis.setConstant(true); }
        |
        (
            [ <FINAL> { jjtThis.setConstant(true); } ]
            ( <VAR>
              |
              ( <INT> { jjtThis.setType(Integer.TYPE); }
                |
                <LONG> { jjtThis.setType(Long.TYPE); }
                |
                <SHORT> { jjtThis.setType(Short.TYPE); }
                |
                <BYTE> { jjtThis.setType(Byte.TYPE); }
                |
                <CHAR> { jjtThis.setType(Character.TYPE); }
                |
                <BOOLEAN> { jjtThis.setType(Boolean.TYPE); }
                |
                <FLOAT> { jjtThis.setType(Float.TYPE); }
                |
                <DOUBLE> { jjtThis.setType(Double.TYPE); }
                |
                LOOKAHEAD( { getToken(1).kind == IDENTIFIER && resolveType(getToken(1).image) != null } ) 
                t=<IDENTIFIER> { jjtThis.setType(resolveType(t.image)); }
                ( LOOKAHEAD(2) <DOT> te=<DOT_IDENTIFIER> { type = resolveNestedType(jjtThis.getType(), te.image); if (type == null) throwParsingException(jjtThis); jjtThis.setType(type); } )*
              ) 
              (<LBRACKET> <RBRACKET> { jjtThis.setArray(); } )*
            )
            [ <and> { jjtThis.setRequired(); } ]
        )
    ) t=<IDENTIFIER>
{
    declareVariable(jjtThis, t); 
    return jjtThis;
}
}

void VarStatement() : 
{
    ASTVar var;
    ASTVar extvar;
}
{
    ( 
        var = DeclareLocalVar() 
        { if ((var.isConstant() || var.isRequired()) && getToken(1).kind != assign) throwParsingException(jjtThis); } 
        [ <assign> Expression() ]
    ) #Initialization()
    (
        LOOKAHEAD(2) <COMMA> 
        ( 
            extvar = DeclareExtVar(var.isLexical(), var.isConstant(), var.getType()) 
            { if ((var.isConstant() || extvar.isRequired()) && getToken(1).kind != assign) throwParsingException(jjtThis); } 
            [ <assign> Expression() ]
        ) #Initialization()
    )*
}

void MultipleVarStatement() : {}
{
    MultipleDeclareVar() <assign> Expression()
}

void MultipleDeclareVar() #MultipleIdentifier :
{
    boolean constant = false;
}
{
    [ <FINAL> { constant = true; jjtThis.setConstant(true); } ] <VAR> <LPAREN> DeclareExtVar(false, constant, null) (<COMMA> DeclareExtVar(false, constant, null))* <RPAREN>
}

void DeclareTryVar() #Var :
{
    Token t;
    Token te;
    Class type;
}
{
    [ <FINAL> { jjtThis.setConstant(true); } ]
    ( <VAR>
      |
      LOOKAHEAD( { getToken(1).kind == IDENTIFIER && resolveType(getToken(1).image) != null } ) 
      t=<IDENTIFIER> { type = resolveType(t.image); }
      ( LOOKAHEAD(2) <DOT> te=<DOT_IDENTIFIER> { type = Parser.resolveNestedType(type, te.image); if (type == null) throwParsingException(te); } )*
      { if (type == null || !AutoCloseable.class.isAssignableFrom(type)) throwParsingException(jjtThis); jjtThis.setType(type); }
    )
    t=<IDENTIFIER> 
{
    declareVariable(jjtThis, t); 
}
}

void DeclareCatchVar() #Var :
{
    Token t;
    Token te;
    Class type;
}
{
    [ <FINAL> { jjtThis.setConstant(true); } ]
    ( <VAR>
      |
      LOOKAHEAD( { getToken(1).kind == IDENTIFIER && resolveType(getToken(1).image) != null } ) 
      t=<IDENTIFIER> { type = resolveType(t.image); }
      ( LOOKAHEAD(2) <DOT> te=<DOT_IDENTIFIER> { type = resolveNestedType(type, te.image); if (type == null) throwParsingException(te); } )*
      { if (type == null || !Throwable.class.isAssignableFrom(type)) throwParsingException(jjtThis); jjtThis.setType(type); }
    )
    t=<IDENTIFIER> 
{
    declareVariable(jjtThis, t);
}
}

void DeclareMultiCatchVar() #MultiVar :
{
    Token t;
    Token te;
    Class type;
}
{
    LOOKAHEAD( { getToken(1).kind == IDENTIFIER && resolveType(getToken(1).image) != null && getToken(2).kind == or} )
    t=<IDENTIFIER> { type = resolveType(t.image); }
    ( LOOKAHEAD(2) <DOT> te=<DOT_IDENTIFIER> { type = resolveNestedType(type, te.image); if (type == null) throwParsingException(te); } )*
    { if (type == null || !Throwable.class.isAssignableFrom(type)) throwParsingException(jjtThis); jjtThis.addType(type); }
    ( LOOKAHEAD({ getToken(1).kind == or && getToken(2).kind == IDENTIFIER && resolveType(Throwable.class, getToken(2).image) != null})
        <or> t=<IDENTIFIER> { type = resolveType(t.image); }
        ( LOOKAHEAD(2) <DOT> te=<DOT_IDENTIFIER> { type = resolveNestedType(type, te.image); if (type == null) throwParsingException(te); } )*
        { if (type == null || !Throwable.class.isAssignableFrom(type)) throwParsingException(jjtThis); jjtThis.addType(type); }
    )+
    t=<IDENTIFIER>
{
    declareVariable(jjtThis, t); 
}
}

void Pragma() #void :
{
    Token t;
    Object value;
}
{
    <PRAGMA> t=<QUALIFIED_IDENTIFIER> value=PragmaValue() { declarePragma(t.image, value); }
}

Object PragmaValue() #void :
{
    Token s = null;
    Token v;
    StringBuilder sb;
    Object result;
}
{
  (
    LOOKAHEAD(2) (s=<plus>|s=<minus>)? v=<INTEGER_LITERAL> { result = NumberParser.parseInteger(s, v); }
    |
    LOOKAHEAD(2) (s=<plus>|s=<minus>)? v=<FLOAT_LITERAL> { result = NumberParser.parseDouble(s, v); }
    |
    v=<STRING_LITERAL> { result = Parser.buildString(v.image, true); }
    |
    v=<IDENTIFIER> { sb = new StringBuilder(v.image); } ( LOOKAHEAD(<DOT>) <DOT> v=<DOT_IDENTIFIER> { sb.append(".").append(v.image); } )* { result = sb.toString(); }
    |
    v=<TRUE> { result = true; }
    |
    v=<FALSE> { result = false; }
    |
    v=<NULL> { result = null; }
    |
    v=<NAN_LITERAL> { result = Double.NaN; }
  )
{
    return result;
}
}


/***************************************
 *      Expression syntax
 ***************************************/

void Expression() #void : {}
{
    AssignmentExpression()
}

void AssignmentExpression() #void : {}
{
    ConditionalExpression()
    ( LOOKAHEAD(2) (
      <plus_assign> Expression() #SetAddNode(2)
      |
      <mult_assign> Expression() #SetMultNode(2)
      |
      <div_assign> Expression() #SetDivNode(2)
      |
      <mod_assign> Expression() #SetModNode(2)
      |
      <and_assign> Expression() #SetAndNode(2)
      |
      <or_assign> Expression() #SetOrNode(2)
      |
      <xor_assign> Expression() #SetXorNode(2)
      |
      <minus_assign> Expression() #SetSubNode(2)
      |
      <lshift_assign>  Expression() #SetShiftLeftNode(2)
      |
      <rshift_assign>  Expression() #SetShiftRightNode(2)
      |
      <rshiftu_assign>  Expression() #SetShiftRightUnsignedNode(2)
      |
      <null_assign> Expression() #NullAssignment(2)
      |
      <ne_assign> Expression() #NEAssignment(2)
      |
      <assign> Expression() #Assignment(2)
    ) )?
}

/***************************************
 *      Conditional & relational
 ***************************************/

void ConditionalExpression() #void : {}
{
    ConditionalOrExpression()
    [ LOOKAHEAD(2) (
      <QMARK> TernaryExpression()
      |
      <ELVIS> Expression() #ElvisNode(2)
    ) ]
}

void TernaryExpression() #void : {}
{
    ( Expression() [ LOOKAHEAD(<COLON>) <COLON> Expression() ] ) #TernaryNode( jjtree.nodeArity() + 1 )
}

void ConditionalOrExpression() #void : {}
{
    ConditionalAndExpression()
    ( LOOKAHEAD(2) (
       (<OR>|<_OR>) ConditionalAndExpression() #OrNode(2)
    ) )*
}

void ConditionalAndExpression() #void : {}
{
    InclusiveOrExpression()
    ( LOOKAHEAD(2) (
       (<AND>|<_AND>) InclusiveOrExpression() #AndNode(2)
    ) )*
}

void InclusiveOrExpression() #void : {}
{
    ExclusiveOrExpression()
    ( LOOKAHEAD(2) (
       <or> ExclusiveOrExpression() #BitwiseOrNode(2)
    ) )*
}

void ExclusiveOrExpression() #void : {}
{
    AndExpression()
    ( LOOKAHEAD(2) (
       <xor> AndExpression() #BitwiseXorNode(2)
    ) )*
}

void AndExpression() #void : {}
{
    EqualityExpression()
    ( LOOKAHEAD(2) (
       <and> EqualityExpression() #BitwiseAndNode(2)
    ) )*
}

void EqualityExpression() #void : {}
{
    RelationalExpression()
    [ LOOKAHEAD(2) (
      (<eq> | <EQ>) RelationalExpressionOperand() #EQNode(2)
    |
      (<ne> | <NE>) RelationalExpressionOperand() #NENode(2)
    |
      (<req> | <IN>) RelationalExpressionOperand() #ERNode(2) // equals regexp
    |
      <rne> RelationalExpressionOperand() #NRNode(2) // not equals regexp
    |
      <is> RangeExpression() #ISNode(2) // identical
    |
      <ni> RangeExpression() #NINode(2) // not identical
    ) ]
}

void SetOperand() : {}
{
    ( <QMARK> { jjtThis.setAny(); } | <NULLP> ) <LPAREN> RangeExpression() (<COMMA> RangeExpression())* <RPAREN>
}

void RelationalExpressionOperand() #void : {}
{
    SetOperand()
    |
    RangeExpression()
}

void RelationalExpression() #void : {}
{
    RangeExpression()
    [ LOOKAHEAD(2) (
      (<lt> |<LT>) RelationalExpressionOperand() #LTNode(2)
    |
      (<gt> | <GT>) RelationalExpressionOperand() #GTNode(2)
    |
      (<le> | <LE>) RelationalExpressionOperand() #LENode(2)
    |
      (<ge> | <GE>) RelationalExpressionOperand() #GENode(2)
    |
      <seq> RelationalExpressionOperand() #SWNode(2) // starts with
    |
      <sne> RelationalExpressionOperand() #NSWNode(2) // not starts with
    |
      <eeq> RelationalExpressionOperand() #EWNode(2) // ends with
    |
      <ene> RelationalExpressionOperand() #NEWNode(2) // not ends with
    |
      <iof> TypeReference() #IOFNode(2) // instanceof
    |
      <niof> TypeReference() #NIOFNode(2) // not instanceof
    ) ]
}

void RangeExpression() #void : {}
{
    ShiftExpression()
    [ LOOKAHEAD(2) (
       <range> ShiftExpression() #RangeNode(2) // range
    ) ]
}

/***************************************
 *      Arithmetic
 ***************************************/
void ShiftExpression() #void : {}
{
    AdditiveExpression()
    ( LOOKAHEAD(2) (
      <lshift> AdditiveExpression() #ShiftLeftNode(2) // left shift
      |
      <rshift> AdditiveExpression() #ShiftRightNode(2) // right shift
      |
      <rshiftu> AdditiveExpression() #ShiftRightUnsignedNode(2) // right shift unsigned
    ) )*
}

void AdditiveExpression() #void : {}
{
    MultiplicativeExpression()
    ( LOOKAHEAD(2) (
      <plus> MultiplicativeExpression() #AddNode(2)
      |
      <minus> MultiplicativeExpression() #SubNode(2)
    ) )*
}

void MultiplicativeExpression() #void : {}
{
    UnaryExpression()
    ( LOOKAHEAD(2) (
      <mult> UnaryExpression() #MulNode(2)
      |
      (<div>|<DIV>) UnaryExpression() #DivNode(2)
      |
      (<mod>|<MOD>) UnaryExpression() #ModNode(2)
    ) )*
}

void UnaryExpression() #void : {}
{
    <minus> UnaryExpression() #UnaryMinusNode(1)
    |
    <unary_minus> UnaryExpression() #UnaryMinusNode(1)
    |
    <plus> UnaryExpression() #UnaryPlusNode(1)
    |
    <increment> UnaryExpression() #IncrementGetNode(1)
    |
    <decrement> UnaryExpression() #DecrementGetNode(1)
    |
    <mult> UnaryExpression() #IndirectNode(1)
    |
    <tilda> UnaryExpression() #BitwiseComplNode(1)
    |
    UnaryExpressionNotPlusMinus()
}

void UnaryExpressionNotPlusMinus() #void : {}
{
    (<not>|<NOT>) UnaryExpression() #NotNode(1)
    |
    <EMPTY> UnaryExpression() #EmptyFunction(1)
    |
    <SIZE> UnaryExpression() #SizeFunction(1)
    |
    <ELLIPSIS> EnumerationExpression()
    |
    LOOKAHEAD(<LPAREN> TypeCastReference() <RPAREN> UnaryExpressionNotPlusMinus()) (<LPAREN> TypeCastReference() <RPAREN> UnaryExpressionNotPlusMinus() #CastNode(2))
    |
    PostfixExpression()
    |
    LOOKAHEAD( <SWITCH> ) SwitchExpression()
}

void PostfixExpression() #void : {}
{
    PointerExpression()
    ( LOOKAHEAD(1) (
      <increment> #GetIncrementNode(1)
      |
      <decrement> #GetDecrementNode(1)
    ) )?
}

void PointerExpression() #void : {}
{
    <and> ValueExpression() #PointerNode(1)
    |
    NullableExpression()
}

void EnumerationExpression() #void : {}
{
    ((IteratorExpression() (LOOKAHEAD(2) EnumerationAccess() )*) #EnumerationReference(>1)) #Reference(>1)
}

void EnumerationAccess() #void : {}
{
    LOOKAHEAD(<DOTC> ProjectionExpression() <COLON>) MapProjection()
    |
    LOOKAHEAD(<DOTC>) ArrayProjection()
    |
    LOOKAHEAD(<DOTB>) Selection()
}

void Selection() #SelectionNode : {}
{
    <DOTB> (
      StopCountSelection()
      |
      StartCountSelection()
      |
      ExpressionLambda()
    ) <RBRACKET>
}

void StopCountSelection() #StopCountNode : {}
{
    (<lt> | <LT>) Expression()
}

void StartCountSelection() #StartCountNode : {}
{
    (<gt> | <GT>) Expression()
}

void ArrayProjection() #ProjectionNode : {}
{
    <DOTC> ProjectionExpression() ( LOOKAHEAD(2) <COMMA> ProjectionExpression() )* <RCURLY>
}

void MapProjection() #MapProjectionNode : {}
{
    <DOTC> ProjectionExpression() <COLON> ProjectionExpression() <RCURLY>
}

void ProjectionExpression() #void : {}
{
    ExpressionLambda()
}

void IteratorExpression() #EnumerationNode : {}
{
    LOOKAHEAD(NullableExpression()) NullableExpression()
    |
    IteratorBlock()
}

void IteratorBlock() #SimpleLambda :
{
    pushScope();
    pushUnit(jjtThis);
    branchScope.yieldReturnCount += 1;
}
{
    Block()
{
    branchScope.yieldReturnCount -= 1;
    popUnit(jjtThis);
    jjtThis.setScope(scope);
    popScope();
}
}

void SwitchExpression() : {}
{
    <SWITCH> <LPAREN> Expression() <RPAREN> <LCURLY> { branchScope.yieldCount += 1; } SwitchExpressionBlock() { branchScope.yieldCount -= 1; } <RCURLY>
}

void SwitchExpressionBlock() #void : {}
{
    SwitchExpressionCase() (LOOKAHEAD(SwitchExpressionBlock()) SwitchExpressionBlock())*
    |
    SwitchExpressionDefault() (LOOKAHEAD(SwitchExpressionCase()) SwitchExpressionCase())*
}

void SwitchExpressionDefault() : {}
{
    <DCASE> <LAMBDA> Statement()
}

void SwitchExpressionCase() : {}
{
    <CASE> SwitchCaseLabel() <LAMBDA> Statement()
}

void SwitchCaseLabel() : {}
{
    NullLiteral() [ <COMMA> <DCASE> { jjtThis.setDefault(); } ]
    |
    (SwitchCaseLiteral() | Identifier()) (<COMMA> (SwitchCaseLiteral() | Identifier()))*
}

void SwitchCaseLiteral() #void : {}
{
    IntegerLiteral()
    |
    JxltLiteral()
    |
    TextBlockLiteral()
    |
    StringLiteral()
}

/***************************************
 *      Identifier & Literals
 ***************************************/

void Identifier(boolean top) :
{
    Token t;
}
{
    t=<IDENTIFIER> { jjtThis.setSymbol(top? checkVariable(jjtThis, t.image) : t.image); if (top && isFinalVariable(t.image)) jjtThis.setConstant(true); }
    |
    t=<REGISTER> { if (!getFeatures().supportsRegister()) throwParsingException(t); jjtThis.setSymbol(t.image); }
}

void NamespaceIdentifier()  #NamespaceIdentifier :
{
    Token ns;
    Token id;
}
{
    ns=<IDENTIFIER> <COLON> id=<IDENTIFIER> { jjtThis.setNamespace(ns.image, id.image); }
}

void RemoveIdentifier() #Identifier :
{
    Token t;
}
{
    t=<REMOVE> { jjtThis.setSymbol(t.image); }
}

void ClassIdentifier() #Identifier :
{
    Token t;
}
{
    t=<CLASS> { jjtThis.setSymbol(t.image); }
}

void MethodReferenceIdentifier() #Identifier :
{
    Token t;
}
{
    t=<SIZE> { jjtThis.setSymbol(t.image); }
    |
    t=<EMPTY> { jjtThis.setSymbol(t.image); }
    |
    t=<REMOVE> { jjtThis.setSymbol(t.image); }
    |
    t=<CLASS> { jjtThis.setSymbol(t.image); }
    |
    t=<NEW> { jjtThis.setSymbol(t.image); }
    |
    t=<FUNCTION> { jjtThis.setSymbol(t.image); }
    |
    t=<VAR> { jjtThis.setSymbol(t.image); }
    |
    t=<YIELD> { jjtThis.setSymbol(t.image); }
    |
    t=<IDENTIFIER> { jjtThis.setSymbol(t.image); }
}

void This() #void : {}
{
    <THIS> #ThisNode
}

void Current() #void : {}
{
    <CURRENT> #CurrentNode
}

void Literal() #void : {}
{
    IntegerLiteral()
    |
    FloatLiteral()
    |
    BooleanLiteral()
    |
    JxltLiteral()
    |
    TextBlockLiteral()
    |
    StringLiteral()
    |
    RegexLiteral()
    |
    NaNLiteral()
}

void UnderscoreLiteral() : {}
{
    <UNDERSCORE>
}

void NaNLiteral() #NumberLiteral : {}
{
    <NAN_LITERAL> { jjtThis.setReal("NaN"); }
}

void NullLiteral() : {}
{
    <NULL>
}

void BooleanLiteral() : {}
{
    <TRUE> { jjtThis.setLiteral(Boolean.TRUE); }
    |
    <FALSE> { jjtThis.setLiteral(Boolean.FALSE); }
}

void IntegerLiteral() #NumberLiteral :
{
    Token t;
}
{
    t=<INTEGER_LITERAL> { jjtThis.setNatural(t.image); }
}

void FloatLiteral() #NumberLiteral:
{
    Token t;
}
{
    t=<FLOAT_LITERAL> { jjtThis.setReal(t.image); }
}

void StringLiteral() :
{
    Token t;
}
{
    t=<STRING_LITERAL> { jjtThis.setLiteral(Parser.buildString(t.image, true)); }
}

void JxltLiteral() #JxltLiteral :
{
    Token t;
}
{
    t=<JXLT_LITERAL> { jjtThis.setLiteral(Parser.buildString(t.image, true)); }
}

void RegexLiteral() :
{
    Token t;
}
{
    t=<REGEX_LITERAL> { jjtThis.setLiteral(Parser.buildRegex(t.image)); }
}

void TextBlockLiteral() :
{
    Token t;
}
{
    t=<BLOCK_LITERAL> { jjtThis.setImage(t.image); jjtThis.setLiteral(Parser.buildBlock(t.image)); }
}

void StringBuilderLiteral() : {}
{
    (JxltLiteral() | TextBlockLiteral() | StringLiteral()) <ELLIPSIS> 
}

void ClassLiteral() :
{
    Token t;
    Token te;
    Class type;
}
{
    (
      t=<INT> { type = Integer.TYPE; }
      |
      t=<LONG> { type = Long.TYPE; }
      |
      t=<SHORT> { type = Short.TYPE; }
      |
      t=<BYTE> { type = Byte.TYPE; }
      |
      t=<CHAR> { type = Character.TYPE; }
      |
      t=<BOOLEAN> { type = Boolean.TYPE; }
      |
      t=<FLOAT> { type = Float.TYPE; }
      |
      t=<DOUBLE> { type = Double.TYPE; }
      |
      t=<VOID> { type = Void.TYPE; }
      |
      LOOKAHEAD( { getToken(1).kind == IDENTIFIER && resolveType(getToken(1).image) != null } ) 
      t=<IDENTIFIER> { type = resolveType(t.image); }
      ( LOOKAHEAD(2) <DOT> te=<DOT_IDENTIFIER> { type = resolveNestedType(type, te.image); if (type == null) throwParsingException(jjtThis); } )*
    )
    <DOT> <CLASS>
{ 
    jjtThis.setLiteral(type); if (isSimpleName(type)) jjtThis.setSimpleName();
}
}

void TypeCastReference() #TypeLiteral :
{
    Token t;
    Token te;
    Class type;
}
{
    (
      t=<INT> { jjtThis.setLiteral(Integer.TYPE); }
      |
      t=<LONG> { jjtThis.setLiteral(Long.TYPE); }
      |
      t=<SHORT> { jjtThis.setLiteral(Short.TYPE); }
      |
      t=<BYTE> { jjtThis.setLiteral(Byte.TYPE); }
      |
      t=<CHAR> { jjtThis.setLiteral(Character.TYPE); }
      |
      t=<BOOLEAN> { jjtThis.setLiteral(Boolean.TYPE); }
      |
      t=<FLOAT> { jjtThis.setLiteral(Float.TYPE); }
      |
      t=<DOUBLE> { jjtThis.setLiteral(Double.TYPE); }
      |
      LOOKAHEAD( { getToken(1).kind == IDENTIFIER && resolveType(getToken(1).image) != null } ) 
      t=<IDENTIFIER> { jjtThis.setLiteral(resolveType(t.image)); }
      ( LOOKAHEAD(2) <DOT> te=<DOT_IDENTIFIER> { type = resolveNestedType(jjtThis.getLiteral(), te.image); if (type == null) throwParsingException(jjtThis); jjtThis.setLiteral(type); } )*
    )
    (LOOKAHEAD(<LBRACKET>) <LBRACKET> <RBRACKET> { jjtThis.setArray(); })*
}

void StaticTypeReference() #TypeLiteral :
{
    Token t;
    Token te;
}
{
    (
      LOOKAHEAD( { getToken(1).kind == IDENTIFIER && resolveType(getToken(1).image) != null } ) 
      t=<IDENTIFIER> { jjtThis.setLiteral(resolveType(t.image)); }
    )
{ 
    if (isSimpleName(jjtThis.getLiteral())) jjtThis.setSimpleName();
}
}

void TypeReference() #TypeLiteral :
{
    Token t;
    Class value;
}
{
    (LOOKAHEAD(<LBRACKET>) <LBRACKET> <RBRACKET> { jjtThis.setArray(); })+
    |
    (
      (
         t=<INT> { jjtThis.setLiteral(Integer.TYPE); }
         |
         t=<LONG> { jjtThis.setLiteral(Long.TYPE); }
         |
         t=<SHORT> { jjtThis.setLiteral(Short.TYPE); }
         |
         t=<BYTE> { jjtThis.setLiteral(Byte.TYPE); }
         |
         t=<CHAR> { jjtThis.setLiteral(Character.TYPE); }
         |
         t=<BOOLEAN> { jjtThis.setLiteral(Boolean.TYPE); }
         |
         t=<FLOAT> { jjtThis.setLiteral(Float.TYPE); }
         |
         t=<DOUBLE> { jjtThis.setLiteral(Double.TYPE); }
      )
      (LOOKAHEAD(<LBRACKET>) <LBRACKET> <RBRACKET> { jjtThis.setArray(); })+
    )
    |
    (
      t=<QUALIFIED_IDENTIFIER> { value = resolveType(t.image); if (value == null) throwParsingException(jjtThis); jjtThis.setLiteral(value); }
      (LOOKAHEAD(<LBRACKET>) <LBRACKET> <RBRACKET> { jjtThis.setArray(); })*
    )
}

void NewTypeReference(Class type) #TypeLiteral :
{
    Token t;
    Class value;
}
{
    t=<QUALIFIED_IDENTIFIER> { value = resolveInstantiableType(t.image); if (value == null || type != null && !type.isAssignableFrom(value)) throwParsingException(jjtThis); jjtThis.setLiteral(value); }
}

void ArrayTypeReference() #void : {}
{
    PrimitiveType()
    |
    ObjectType()
}

void ObjectType() #TypeLiteral :
{
    Token t;
    Class value;
}
{
    t=<QUALIFIED_IDENTIFIER> { value = resolveType(t.image); if (value == null) throwParsingException(jjtThis); jjtThis.setLiteral(value); }
}

void InnerType() #Identifier :
{
    Token t;
}
{
    t=<QUALIFIED_IDENTIFIER> { jjtThis.setSymbol(t.image); }
}

void PrimitiveType() #TypeLiteral :
{
    Token t;
}
{
    t=<INT> { jjtThis.setLiteral(Integer.TYPE); }
    |
    t=<LONG> { jjtThis.setLiteral(Long.TYPE); }
    |
    t=<SHORT> { jjtThis.setLiteral(Short.TYPE); }
    |
    t=<BYTE> { jjtThis.setLiteral(Byte.TYPE); }
    |
    t=<CHAR> { jjtThis.setLiteral(Character.TYPE); }
    |
    t=<BOOLEAN> { jjtThis.setLiteral(Boolean.TYPE); }
    |
    t=<FLOAT> { jjtThis.setLiteral(Float.TYPE); }
    |
    t=<DOUBLE> { jjtThis.setLiteral(Double.TYPE); }
}

void EmptyListLiteral() #ArrayLiteral : {}
{
    <LBRACKET> [ <ELLIPSIS> { jjtThis.setExtended(); } ] <RBRACKET>
}

void ArrayLiteral() : {}
{
    <LBRACKET>
        Expression() (LOOKAHEAD(<COMMA> Expression()) <COMMA> Expression() )* [LOOKAHEAD(2) <COMMA> <ELLIPSIS> { jjtThis.setExtended(); } ]
    <RBRACKET>
}

void ImmutableArrayLiteral() #ArrayLiteral :
{
    jjtThis.setImmutable();
}
{
    <HBRACKET> [ Expression() (<COMMA> Expression() )* ] <RBRACKET>
}

void EmptyMapLiteral() #MapLiteral : {}
{
    <LCURLY> <COLON> [ <ELLIPSIS> { jjtThis.setOrdered(); } ] <RCURLY>
}

void MapLiteral() : {}
{
    <LCURLY>
        MapElement() (LOOKAHEAD(<COMMA> MapElement()) <COMMA> MapElement() )* [LOOKAHEAD(2) <COMMA> <ELLIPSIS> { jjtThis.setOrdered(); } ]
    <RCURLY>
}

void MapElement() #void : {}
{
    LOOKAHEAD(<mult> <COLON> <ELLIPSIS>) <mult> <COLON> <ELLIPSIS> EnumerationExpression() #MapEnumerationNode(1)
    |
    MapEntry()
}

void MapEntry() : {}
{
    Expression() <COLON> Expression()
}

void MapEntryLiteral() : {}
{
    <LBRACKET> Expression() <COLON> Expression() <RBRACKET>
}

void ImmutableEmptyMapLiteral() #MapLiteral :
{
    jjtThis.setImmutable();
}
{
    <HCURLY> <COLON> <RCURLY>
}

void ImmutableMapLiteral() #MapLiteral :
{
    jjtThis.setImmutable();
}
{
    <HCURLY>
        MapElement() (LOOKAHEAD(<COMMA> MapElement()) <COMMA> MapElement() )* [LOOKAHEAD(2) <COMMA> <ELLIPSIS> { jjtThis.setOrdered(); } ]
    <RCURLY>
}

void EmptySetLiteral() #SetLiteral : {}
{
    <LCURLY> [ <ELLIPSIS> { jjtThis.setOrdered(); } ] <RCURLY>
}

void SetLiteral() : {}
{
    <LCURLY> Expression() ( LOOKAHEAD(<COMMA> Expression()) <COMMA> Expression() )* [ LOOKAHEAD(<COMMA> <ELLIPSIS> <RCURLY>) <COMMA> <ELLIPSIS> { jjtThis.setOrdered(); } ] <RCURLY>
}

void ImmutableEmptySetLiteral() #SetLiteral :
{
    jjtThis.setImmutable();
}
{
    <HCURLY> <RCURLY>
}

void ImmutableSetLiteral() #SetLiteral :
{
    jjtThis.setImmutable();
}
{
    <HCURLY> Expression() ( LOOKAHEAD(<COMMA> Expression()) <COMMA> Expression() )* [ LOOKAHEAD(<COMMA> <ELLIPSIS> <RCURLY>) <COMMA> <ELLIPSIS> { jjtThis.setOrdered(); } ] <RCURLY>
}

/***************************************
 *      Functions & Methods
 ***************************************/

void Arguments() #Arguments : {}
{
    <LPAREN> (Expression() (<COMMA> Expression())* )? <RPAREN>
}

void FunctionCallLookahead() #void : {}
{
    LOOKAHEAD(<IDENTIFIER> <COLON> <IDENTIFIER> <LPAREN>,  { isDeclaredNamespace(getToken(1), getToken(2)) }) <IDENTIFIER> <COLON> <IDENTIFIER> <LPAREN>
    |
    LOOKAHEAD(2) <IDENTIFIER> <LPAREN>
    |
    <REGISTER> <LPAREN>
    |
    <REMOVE> <LPAREN>
    |
    <CLASS> <LPAREN>
}

void FunctionCall() #void : {}
{
    LOOKAHEAD(<IDENTIFIER> <LPAREN>) Identifier(true) Arguments() #FunctionNode(2)
    |
    LOOKAHEAD(<IDENTIFIER> <COLON> <IDENTIFIER> <LPAREN>,  { isDeclaredNamespace(getToken(1), getToken(2)) }) NamespaceIdentifier() Arguments() #FunctionNode(2)
    |
    LOOKAHEAD(2) RemoveIdentifier() Arguments() #FunctionNode(2)
    |
    LOOKAHEAD(2) ClassIdentifier() Arguments() #FunctionNode(2)
}

void Constructor() #void : {}
{
    <NEW>
    (
       LOOKAHEAD(<LPAREN>) ForNameConstructor()
       |
       LOOKAHEAD(<QUALIFIED_IDENTIFIER> <LPAREN>) QualifiedConstructor()
       |
       LOOKAHEAD(<QUALIFIED_IDENTIFIER> <LCURLY> MapElement()) InitializedMapConstructor()
       |
       LOOKAHEAD(<QUALIFIED_IDENTIFIER> <LCURLY>) InitializedCollectionConstructor()
       |
       LOOKAHEAD(ArrayTypeReference() <LBRACKET> <RBRACKET>) InitializedArrayConstructor()
       |
       LOOKAHEAD(ArrayTypeReference() <LBRACKET>) ArrayConstructor()
    )
}

void ForNameConstructor() #ConstructorNode : {}
{
    <LPAREN> Expression() ( <COMMA> Expression() )* <RPAREN>
}

void QualifiedConstructor() #QualifiedConstructorNode : {}
{
    NewTypeReference(null) Arguments()
}

void ArrayConstructor() #ArrayConstructorNode : {}
{
    ArrayTypeReference() (LOOKAHEAD(2) ArrayQualifiedDimension())+ (LOOKAHEAD(2) ArrayOpenDimension())*
}

void ArrayQualifiedDimension() #void : {}
{
    <LBRACKET> Expression() <RBRACKET>
}

void ArrayOpenDimension() : {}
{
    <LBRACKET> <RBRACKET>
}

void InitializedArrayConstructor() #InitializedArrayConstructorNode : {}
{
    ArrayTypeReference() <LBRACKET> <RBRACKET> InitializedCollectionLiteral()
}

void InitializedCollectionConstructor() #InitializedCollectionConstructorNode : {}
{
    NewTypeReference(Collection.class) InitializedCollectionLiteral()
}

void InitializedMapConstructor() #InitializedMapConstructorNode : {}
{
    NewTypeReference(Map.class) InitializedMapLiteral()
}

void InitializedCollectionLiteral() #void : {}
{
    <LCURLY> [ Expression() ( <COMMA> Expression() )* ] <RCURLY>
}

void InitializedMapLiteral() #void : {}
{
    <LCURLY> [ MapElement() ( <COMMA> MapElement() )* ] <RCURLY>
}

void Parameter() #void :
{
    Token t;
    boolean lexical = false;
    boolean constant = false;
}
{
    [ 
       <LET> { lexical = true; } 
       |
       <CONST> { lexical = true; constant = true; }
    ]
    t=<IDENTIFIER> 
{
    declareParameter(t, null, lexical, constant, false, null); 
}
}

void VarParameter() #void :
{
    Token t;
    Token te;
    Class type = null;
    boolean constant = false;
    boolean required = false;
    Token v;
    Object value = null;
}
{
    [ <FINAL> { constant = true; } ]
    ( <VAR>
      |
      (
         <INT> { type = Integer.TYPE; }
         |
         <LONG> { type = Long.TYPE; }
         |
         <SHORT> { type = Short.TYPE; }
         |
         <BYTE> { type = Byte.TYPE; }
         |
         <CHAR> { type = Character.TYPE; }
         |
         <BOOLEAN> { type = Boolean.TYPE; }
         |
         <FLOAT> { type = Float.TYPE; }
         |
         <DOUBLE> { type = Double.TYPE; }
         |
         LOOKAHEAD( { getToken(1).kind == IDENTIFIER && resolveType(getToken(1).image) != null } ) 
         t=<IDENTIFIER> { type = resolveType(t.image); }
         ( LOOKAHEAD(2) <DOT> te=<DOT_IDENTIFIER> { type = resolveNestedType(type, te.image); if (type == null) throwParsingException(te); } )*
      ) 
      (LOOKAHEAD(<LBRACKET>) <LBRACKET> <RBRACKET> { type = Parser.arrayType(type); })*
    )
    [ <and> { required = true; } ]
    t = <IDENTIFIER> 
    [ 
       <assign> 
       (
           v = <INTEGER_LITERAL> { value = NumberParser.parseInteger(null, v); }
           |
           v = <FLOAT_LITERAL> { value = NumberParser.parseDouble(null, v); }
           |
           v = <TRUE> { value = Boolean.TRUE; }
           |
           v = <FALSE> { value = Boolean.FALSE; }
           |
           v = <NULL> { value = null; }
           |
           v = <STRING_LITERAL> { value = Parser.buildString(v.image, true); }
           |
           v = <REGEX_LITERAL> { value = Pattern.compile(Parser.buildRegex(v.image)); }
           |
           v = <NAN_LITERAL> { value = Double.NaN; }
           |
           v = <IDENTIFIER> { value = resolveStaticField(v, type, v.image); }
       )
       |
       <ELLIPSIS> { declareVarArgSupport(); } 
    ]
{
    declareParameter(t, type, false, constant, required, value); 
}
}

void Parameters() #void : {}
{
    <LPAREN>
      [
        LOOKAHEAD(VarParameter()) VarParameter() (LOOKAHEAD( {getToken(1).kind == COMMA && !isVarArgs()} ) <COMMA> VarParameter())*
        |
        Parameter() (<COMMA> Parameter())* [ <ELLIPSIS> { declareVarArgSupport(); } ]
      ]
    <RPAREN>
}

void LambdaLookahead() #void : {}
{
    [ <STATIC> ] 
    (
        <FUNCTION> ( <LPAREN> | <LCURLY> )
        |
        FunctionType() Parameters() <LCURLY>
        |
        Parameters() ( <LAMBDA> | <FATARROW> ) 
    )
    |
    Parameter() ( <LAMBDA> | <FATARROW> )
}

void Lambda() #JexlLambda :
{
    pushScope();
    pushUnit(jjtThis);
    Class type = null;
    Token arrow;
}
{
    (
        [ <STATIC> { declareStaticSupport(); } ]
        (
          <FUNCTION> [ Parameters() ] Block()
          |
          LOOKAHEAD( FunctionType() ) type = FunctionType() { declareReturnType(type); } Parameters() Block()
          |
          Parameters() (arrow=<LAMBDA> | arrow=<FATARROW>) { checkLambda(arrow); } ( LOOKAHEAD(3) Block() | Expression())
        )
        |
        Parameter() (arrow=<LAMBDA> | arrow=<FATARROW>) { checkLambda(arrow); } ( LOOKAHEAD(3) Block() | Expression())
    )
{    
    popUnit(jjtThis);
    jjtThis.setScope(scope);
    popScope();
}
}


/***************************************
 *     References
 ***************************************/

void IdentifierAccess() #void :
{
    Token t;
}
{
    <DOT> (
        t=<DOT_IDENTIFIER> { jjtThis.setIdentifier(t.image); } #IdentifierAccess
        |
        t=<NEW> { jjtThis.setIdentifier(t.image); } #IdentifierAccess
        |
        t=<CLASS> { jjtThis.setIdentifier(t.image); } #IdentifierAccess
        |
        t=<STRING_LITERAL> { jjtThis.setIdentifier(Parser.buildString(t.image, true)); } #IdentifierAccess
        |
        t=<JXLT_LITERAL> { jjtThis.setIdentifier(Parser.buildString(t.image, true)); } #IdentifierAccessJxlt
    )
    |
    <QDOT> (
        t=<DOT_IDENTIFIER> { jjtThis.setIdentifier(t.image); } #IdentifierAccessSafe
        |
        t=<NEW> { jjtThis.setIdentifier(t.image); } #IdentifierAccessSafe
        |
        t=<CLASS> { jjtThis.setIdentifier(t.image); } #IdentifierAccessSafe
        |
        t=<STRING_LITERAL> { jjtThis.setIdentifier(Parser.buildString(t.image, true)); } #IdentifierAccessSafe
        |
        t=<JXLT_LITERAL> { jjtThis.setIdentifier(Parser.buildString(t.image, true)); } #IdentifierAccessSafeJxlt
    )
}

void FieldAccess() #void :
{
    Token t;
}
{
    <DOTAT> (
        t=<DOT_IDENTIFIER> { jjtThis.setIdentifier(t.image); } #FieldAccess
    )
}

void ArrayAccess() : {}
{
    <LBRACKET> Expression() ( <COMMA> Expression() )* <RBRACKET>
}

void ArrayAccessSafe() : {}
{
    <QLBRACKET> Expression() ( <COMMA> Expression() )* <RBRACKET>
}

void ReferenceExpression() #MethodNode(>1) : {}
{
    ( <LPAREN> (
      LOOKAHEAD(Expression()) Expression() | { branchScope.yieldCount += 1; } Block() { branchScope.yieldCount -= 1; }
    ) <RPAREN> #EnclosedExpression(1) ) ( LOOKAHEAD(<LPAREN>) Arguments() )*
}

void PrimaryExpression() #void : {}
{
    LOOKAHEAD( LambdaLookahead() ) Lambda()
    |
    LOOKAHEAD( <LPAREN> ) ReferenceExpression()
    |
    LOOKAHEAD( EmptyMapLiteral() ) EmptyMapLiteral()
    |
    LOOKAHEAD( <LCURLY> MapElement() ) MapLiteral()
    |
    LOOKAHEAD( ImmutableEmptyMapLiteral() ) ImmutableEmptyMapLiteral()
    |
    LOOKAHEAD( <HCURLY> MapElement() ) ImmutableMapLiteral()
    |
    LOOKAHEAD( EmptySetLiteral() ) EmptySetLiteral()
    |
    LOOKAHEAD( <LCURLY> Expression() (<COMMA> | <RCURLY>)) SetLiteral()
    |
    LOOKAHEAD( ImmutableEmptySetLiteral() ) ImmutableEmptySetLiteral()
    |
    LOOKAHEAD( <HCURLY> Expression() (<COMMA> | <RCURLY>)) ImmutableSetLiteral()
    |
    LOOKAHEAD( EmptyListLiteral() ) EmptyListLiteral()
    |
    LOOKAHEAD( <LBRACKET> Expression() <COLON> ) MapEntryLiteral()
    |
    LOOKAHEAD( <LBRACKET> ) ArrayLiteral()
    |
    LOOKAHEAD( <HBRACKET> ) ImmutableArrayLiteral()
    |
    LOOKAHEAD( <NEW> ) Constructor()
    |
    LOOKAHEAD( FunctionCallLookahead() ) FunctionCall()
    |
    This()
    |
    Current()
    |
    LOOKAHEAD( StringBuilderLiteral() ) StringBuilderLiteral()
    |
    Literal()
    |
    LOOKAHEAD( ClassLiteral() ) ClassLiteral()
    |
    LOOKAHEAD( StaticTypeReference() <DOT> ) StaticTypeReference()
    |
    Identifier(true)
}

void NullableExpression() #void : {}
{
    (NullLiteral() | ValueExpression())
    ( LOOKAHEAD( <NULLP> )
       <NULLP> NullableExpression() #NullpNode(2)
    )*
}

void ValueExpression() #void : {}
{
    ( PrimaryExpression() ( LOOKAHEAD(2) MemberExpression() )* [LOOKAHEAD(2) MethodReference()] ) #Reference(>1)
}

void MemberExpression() #void : {}
{
    LOOKAHEAD(MethodCall()) MethodCall()
    |
    MemberAccess()
}

void MethodCall() #void : {}
{
    LOOKAHEAD(<DOT> <NEW> InnerType()) (<DOT> <NEW> InnerType() Arguments()) #InnerConstructorNode()
    |
    (MemberAccess() (LOOKAHEAD(<LPAREN>) Arguments())+) #MethodNode(>1)
}

void Pipe() #PipeNode : {}
{
    <DOTP> Expression() <RPAREN>
}

void MemberAccess() #void : {}
{
    LOOKAHEAD(<LBRACKET>) ArrayAccess()
    |
    LOOKAHEAD(<QLBRACKET>) ArrayAccessSafe()
    |
    LOOKAHEAD(<DOTP>) Pipe()
    |
    LOOKAHEAD(<DOTAT>) FieldAccess()
    |
    LOOKAHEAD(<DOT> | <QDOT>) IdentifierAccess()
    |
    LOOKAHEAD(<LCURLY>) InlinePropertyAssignment()
}

void MethodReference() : {}
{
    <DCOLON> MethodReferenceIdentifier()
}

void InlinePropertyAssignment() : {}
{
    <LCURLY> [ InlinePropertyBlock() ( <COMMA> InlinePropertyBlock() )* ] <RCURLY>
}

void InlineMemberAccess() #void : {}
{
    LOOKAHEAD(<LBRACKET>) ArrayAccess()
    |
    LOOKAHEAD(<DOT>) IdentifierAccess()
    |
    LOOKAHEAD(<DOTAT>) FieldAccess()
}

void InlinePropertyBlock() #void : {}
{
    LOOKAHEAD(InlineFieldName() <COLON> ) InlineFieldEntry()
    |
    LOOKAHEAD(InlineFieldName() <ELVIS> ) InlineFieldNullEntry()
    |
    LOOKAHEAD(InlineFieldName() <EN_ASSIGN> ) InlineFieldNEEntry()
    |
    LOOKAHEAD(InlinePropertyName() <COLON> ) InlinePropertyEntry()
    |
    LOOKAHEAD(InlinePropertyName() <ELVIS> ) InlinePropertyNullEntry()
    |
    LOOKAHEAD(InlinePropertyName() <EN_ASSIGN> ) InlinePropertyNEEntry()
    |
    LOOKAHEAD(<LBRACKET> Expression() <RBRACKET> <COLON> ) InlinePropertyArrayEntry()
    |
    LOOKAHEAD(<LBRACKET> Expression() <RBRACKET> <ELVIS> ) InlinePropertyArrayNullEntry()
    |
    LOOKAHEAD(<LBRACKET> Expression() <RBRACKET> <EN_ASSIGN> ) InlinePropertyArrayNEEntry()
    |
    ((LOOKAHEAD(<LBRACKET>) ArrayAccess() | Identifier()) (LOOKAHEAD(2) InlineMemberAccess() )* InlinePropertyAssignment()) #Reference()
}

void AttributeReference() :
{
    Token t;
}
{
    t=<ANNOTATION> { jjtThis.setName(t.image); }
}

void InlineFieldName() #void : {}
{
    AttributeReference()
}

void InlinePropertyName() #void : {}
{
    Identifier()
    |
    StringLiteral()
    |
    JxltLiteral()
}

void InlineFieldEntry() : {}
{
    InlineFieldName() <COLON> Expression()
}

void InlineFieldNullEntry() : {}
{
    InlineFieldName() <ELVIS> Expression()
}

void InlineFieldNEEntry() : {}
{
    InlineFieldName() <EN_ASSIGN> Expression()
}

void InlinePropertyEntry() : {}
{
    InlinePropertyName() <COLON> Expression()
}

void InlinePropertyNullEntry() : {}
{
    InlinePropertyName() <ELVIS> Expression()
}

void InlinePropertyNEEntry() : {}
{
    InlinePropertyName() <EN_ASSIGN> Expression()
}

void InlinePropertyArrayEntry() : {}
{
    <LBRACKET> Expression() <RBRACKET> <COLON> Expression()
}

void InlinePropertyArrayNullEntry() : {}
{
    <LBRACKET> Expression() <RBRACKET> <ELVIS> Expression()
}

void InlinePropertyArrayNEEntry() : {}
{
    <LBRACKET> Expression() <RBRACKET> <EN_ASSIGN> Expression()
}
