<?xml version="1.0"?>
<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->

<document>
    <properties>
        <title>Apache Commons JEXL Overview</title>
    </properties>

    <body>
        <section name="Java Expression Language (JEXL)">
            <p>
JEXL is a library intended to facilitate the implementation of dynamic and scripting features in
applications and frameworks written in Java.
</p>
<p>
JEXL implements an Expression Language based on some extensions to the JSTL Expression Language supporting most of the
constructs seen in shell-script or ECMAScript.
<br/>
Its goal is to expose scripting features usable by technical operatives or consultants
working with enterprise platforms.
            </p>
            <p>
            The library exposes a small footprint API
            - the <a href="apidocs/org/apache/commons/jexl3/package-summary.html#usage">core features</a> fit in
            3 classes and 10 methods - that can be used in various conditions:
                <ul>
                    <li>Scripting features:
                        <ul><li>Your application lets (advanced) users evaluate or define some simple expressions
                        like computation formulas.</li></ul>
                    </li>
                    <li>Module or component configuration:
                        <ul>
                            <li>Your application has configuration files (eventually generated by a design module)
                            consumed by the end-user module that would benefit from variables and expressions.
                            </li>
                            <li>When it would be convenient to use IOC but overall complexity doesn't require
                            (or can't depend upon) a full-blown library (Spring, Guice...).
                            </li>
                        </ul>
                    </li>
                    <li>Loose-coupling of interfaces and implementations or duck-typing:
                        <ul>
                            <li>You have optional classes that your code cant consider as compilation dependencies.</li>
                            <li>You have to integrate and call "legacy" code or use components that you dont want to
                            strongly depend upon.</li>
                        </ul>
                    </li>
                    <li>Simple template capabilities:
                        <ul><li>Your application has basic template requirements and JSPs or
                        Velocity would be overkill or too inconvenient to deploy.</li></ul>
                    </li>
                </ul>
            </p>
            <p>
            JEXL name stands for Java EXpression Language, a simple expression language originally inspired by Apache
            Velocity and the Expression Language defined in the JavaServer Pages Standard Tag Library version 1.1 (JSTL)
            and JavaServer Pages version 2.0 (JSP).
            JEXL 2.0 added features inspired by
            <a href="https://en.wikipedia.org/wiki/Unified_Expression_Language">Unified EL</a>.
            The syntax is now close to a mix of ECMAScript and "shell-script"
            making it easy to master by technical operatives or consultants. The objects exposed and their behavior
            obviously need to be documented though...
            </p>
            <p>
            The API and the expression language exploit Java-beans naming patterns through
            introspection to expose property getters and setters. It also considers public class fields
            as properties and allows to invoke any accessible method.
            </p>
            <p>
            JEXL attempts to bring some of the lessons learned by the Velocity
            community about expression languages in templating to a wider audience.
                <a href="https://commons.apache.org/jelly">Commons Jelly</a> needed
            Velocity-ish method access, it just had to have it.
            </p>
            <p>
            It must be noted that JEXL is <strong>not</strong> a compatible implementation of EL as defined
            in JSTL 1.1 (JSR-052) or JSP 2.0 (JSR-152). For a compatible implementation of
            these specifications, see the <a href="https://commons.apache.org/el">Commons EL</a> project.
            </p>
        </section>

        <section name="A Brief Example">
            <p>
            When evaluating expressions, JEXL merges an
                <a href="apidocs/org/apache/commons/jexl3/JexlExpression.html">JexlExpression</a>
                or a
                <a href="apidocs/org/apache/commons/jexl3/JexlScript.html">JexlScript</a>
            with a
                <a href="apidocs/org/apache/commons/jexl3/JexlContext.html">JexlContext</a>.
            An Expression is created using
                <a href="apidocs/org/apache/commons/jexl3/JexlEngine.html#createExpression(java.lang.String)">JexlEngine#createExpression()</a>,
            passing a String containing valid JEXL syntax.  A simple JexlContext can be created by instantiating a
                <a href="apidocs/org/apache/commons/jexl3/MapContext.html">MapContext</a>;
            a map of variables that will be internally wrapped can be optionally provided through its constructor.
            The following example, takes a variable named foo, and invokes the bar() method on the property innerFoo:
            </p>
            <p>
                JEXL's intention is a tight integration with its hosting platform; the scripting syntax is very close
                to JScript but leverages (potentially) any public class or method that Java exposes. How tight and how
                rich this integration is up to you; deriving JEXL API classes - most notably JexlPermissions, JexlContext,
                JexlArithmetic - are the means to that end.
            </p>
            <p>The following example illustrate these aspects. It uses a specific set of permissions to allow using
            URI class and a tailored context to expose streams in a convenient manner.</p>
            <!--
            using http://java2html.blogspot.com to prettify code, minor edits; ugly to look at a source, pretty rendered
            -->
            <div>
<pre style="text-align: left; border: 1px dashed #008DEF; line-height: 18px; padding: 15px; font-size: 13px; font-family:'Courier New', Courier, monospace; overflow: auto;"><span style='color:#3F5FBF'>/**
 * A test around scripting streams.
 */</span>
<span style='font-weight:bold;color:#7B0052;'>public</span> <span style='font-weight:bold;color:#7B0052;'>class</span> StreamTest <span style='font-weight:bold;color:#D3171B'>{</span>
    <span style='color:#3F5FBF'>/** Our engine instance. */</span>
    <span style='font-weight:bold;color:#7B0052;'>private</span> <span style='font-weight:bold;color:#7B0052;'>final</span> JexlEngine jexl;

    <span style='font-weight:bold;color:#7B0052;'>public</span> StreamTest() <span style='font-weight:bold;color:#D3171B'>{</span>
        <span style='color:#3F7F5F'>// Restricting features; no loops, no side effects
</span>        JexlFeatures features = <span style='font-weight:bold;color:#7B0052;'>new</span> JexlFeatures()
                .loops(<span style='font-weight:bold;color:#7B0052;'>false</span>)
                .sideEffectGlobal(<span style='font-weight:bold;color:#7B0052;'>false</span>)
                .sideEffect(<span style='font-weight:bold;color:#7B0052;'>false</span>);
        <span style='color:#3F7F5F'>// Restricted permissions to a safe set but with URI allowed
</span>        JexlPermissions permissions = <span style='font-weight:bold;color:#7B0052;'>new</span> ClassPermissions(java.net.URI.class);
        <span style='color:#3F7F5F'>// Create the engine
</span>        jexl = <span style='font-weight:bold;color:#7B0052;'>new</span> JexlBuilder().features(features).permissions(permissions).create();
    <span style='font-weight:bold;color:#D3171B'>}</span>

    <span style='color:#3F5FBF'>/**
     * A MapContext that can operate on streams.
     */</span>
    <span style='font-weight:bold;color:#7B0052;'>public</span> <span style='font-weight:bold;color:#7B0052;'>static</span> <span style='font-weight:bold;color:#7B0052;'>class</span> StreamContext <span style='font-weight:bold;color:#7B0052;'>extends</span> MapContext <span style='font-weight:bold;color:#D3171B'>{</span>
        <span style='color:#3F5FBF'>/**
         * This allows using a JEXL lambda as a mapper.
         * @param stream the stream
         * @param mapper the lambda to use as mapper
         * @return the mapped stream
         */</span>
        <span style='font-weight:bold;color:#7B0052;'>public</span> Stream&lt;?&gt; map(Stream&lt;?&gt; stream, <span style='font-weight:bold;color:#7B0052;'>final</span> JexlScript mapper) <span style='font-weight:bold;color:#D3171B'>{</span>
            <span style='font-weight:bold;color:#7B0052;'>return</span> stream.map( x -&gt; mapper.execute(this, x));
        <span style='font-weight:bold;color:#D3171B'>}</span>

        <span style='color:#3F5FBF'>/**
         * This allows using a JEXL lambda as a filter.
         * @param stream the stream
         * @param filter the lambda to use as filter
         * @return the filtered stream
         */</span>
        <span style='font-weight:bold;color:#7B0052;'>public</span> Stream&lt;?&gt; filter(Stream&lt;?&gt; stream, <span style='font-weight:bold;color:#7B0052;'>final</span> JexlScript filter) <span style='font-weight:bold;color:#D3171B'>{</span>
            <span style='font-weight:bold;color:#7B0052;'>return</span> stream.filter(x -&gt; x =! <span style='font-weight:bold;color:#7B0052;'>null</span> &amp;&amp; TRUE.equals(filter.execute(this, x)));
        <span style='font-weight:bold;color:#D3171B'>}</span>
    <span style='font-weight:bold;color:#D3171B'>}</span>

    @Test
    <span style='font-weight:bold;color:#7B0052;'>public</span> <span style='font-weight:bold;color:#7B0052;'>void</span> testURIStream() <span style='font-weight:bold;color:#7B0052;'>throws</span> Exception <span style='font-weight:bold;color:#D3171B'>{</span>
        <span style='color:#3F7F5F'>// let's assume a collection of uris need to be processed and transformed to be simplified ;
</span>        <span style='color:#3F7F5F'>// we want only http/https ones, only the host part and forcing an https scheme
</span>        List&lt;URI&gt; uris = Arrays.asList(
                URI.create(<span style='color:#2A00FF'>"http://user@www.apache.org:8000?qry=true"</span>),
                URI.create(<span style='color:#2A00FF'>"https://commons.apache.org/releases/prepare.html"</span>),
                URI.create(<span style='color:#2A00FF'>"mailto:henrib@apache.org"</span>)
        );
        <span style='color:#3F7F5F'>// Create the test control, the expected result of our script evaluation
</span>        List&lt;?&gt; control =  uris.stream()
                .map(uri -&gt; uri.getScheme().startsWith(<span style='color:#2A00FF'>"http"</span>)? <span style='color:#2A00FF'>"https://"</span> + uri.getHost() : <span style='font-weight:bold;color:#7B0052;'>null</span>)
                .filter(x -&gt; x != <span style='font-weight:bold;color:#7B0052;'>null</span>)
                .collect(Collectors.toList());
        Assert.assertEquals(2, control.size());

        <span style='color:#3F7F5F'>// Create scripts:
</span>        <span style='color:#3F7F5F'>// uri is the name of the variable used as parameter; the beans are exposed as properties
</span>        <span style='color:#3F7F5F'>// note the starts-with operator =^
</span>        <span style='color:#3F7F5F'>// note that uri is also used in the back-quoted string that performs variable interpolation
</span>        JexlScript mapper = jexl.createScript(<span style='color:#2A00FF'>"uri.scheme =^ 'http'? `https://${uri.host}` : null"</span>, <span style='color:#2A00FF'>"uri"</span>);
        <span style='color:#3F7F5F'>// using the bang-bang / !! - JScript like -  is the way to coerce to boolean in the filter
</span>        JexlScript transform = jexl.createScript(
                <span style='color:#2A00FF'>"list.stream().map(mapper).filter(x -&gt; !!x).collect(Collectors.toList())"</span>, <span style='color:#2A00FF'>"list"</span>);

        <span style='color:#3F7F5F'>// Execute scripts:
</span>        JexlContext sctxt = <span style='font-weight:bold;color:#7B0052;'>new</span> StreamContext();
        <span style='color:#3F7F5F'>// expose the static methods of Collectors; java.util.* is allowed by permissions
</span>        sctxt.set(<span style='color:#2A00FF'>"Collectors"</span>, Collectors.class);
        <span style='color:#3F7F5F'>// expose the mapper script as a global variable in the context
</span>        sctxt.set(<span style='color:#2A00FF'>"mapper"</span>, mapper);

        Object transformed = transform.execute(sctxt, uris);
        Assert.assertTrue(transformed <span style='font-weight:bold;color:#7B0052;'>instanceof</span> List&lt;?&gt;);
        Assert.assertEquals(control, transformed);
    <span style='font-weight:bold;color:#D3171B'>}</span>
<span style='font-weight:bold;color:#D3171B'>}</span></pre>
            </div>

            <source><![CDATA[
    // Create or retrieve an engine
    JexlEngine jexl = new JexlBuilder().create();
    
    // Create an expression
    String jexlExp = "foo.innerFoo.bar()";
    JexlExpression e = jexl.createExpression( jexlExp );
    
    // Create a context and add data
    JexlContext jc = new MapContext();
    jc.set("foo", new Foo() );
    
    // Now evaluate the expression, getting the result
    Object o = e.evaluate(jc);]]></source>
        </section>

        <section name="Extensions to JSTL Expression Language">
            <p>
    While JEXL is similar to the expression language defined in JSTL, it has improved
    upon the syntax in a few areas:
            </p>
            <ul>
                <li>Support for invocation of any accessible method (see example above).</li>
                <li>Support for setting/getting any accessible public field.</li>
                <li>A general <span class="literal">new()</span> method allowing to instantiate objects.</li>
                <li>A general <span class="literal">size()</span> method, which works on:
                    <ul>
                        <li><span class="literal">String</span> - returns length</li>
                        <li><span class="literal">Map</span> - returns number of keys</li>
                        <li><span class="literal">List</span> - returns number of elements.</li>
                    </ul>
                </li>
                <li>A general <span class="literal">empty()</span> method, which works on Collections and Strings.</li>
                <li>Support for the ternary operator 'a ? b : c' - and its GNU-C / "Elvis" variant 'a ?: c'.</li>
                <li>Support for the Perl-like regex matching operators '=~' and '!~'</li>
                <li>Support for the CSS3-inspired 'startsWith' and 'endsWith' operators '=^' and '=$'</li>
                <li>Support for user-defined functions.</li>
                <li>Misc : '+' has been overloaded to be use as a String concatenation operator</li>
            </ul>

        </section>

        <section name="Related Resources">
            <p>
          JEXL is not a product of the Java Community Process (JCP), but it provides a
          similar expression syntax.  For more information about JSP 2.0 EL and JSTL 1.1
          EL:
            </p>
            <ul>
                <li>
                    <a href="http://www.oracle.com/technetwork/java/index-jsp-138231.html">JSP 2.0</a> is covered
            by Java Specification Requests (JSR)
                    <a href="http://www.jcp.org/en/jsr/detail?id=152">JSR-152: JavaServer
            Pages 2.0 Specification</a>.
                </li>
                <li>
            Apache has an implementation of the expression language for JSP 2.0,
            called <a href="https://commons.apache.org/el/index.html">EL</a>
                </li>
                <li>
                    <a href="http://www.oracle.com/technetwork/java/index-jsp-135995.html">JSTL 1.1</a> is covered
            by <a href="http://jcp.org/en/jsr/detail?id=52">JSR 52: A Standard
            Tag Library for JavaServer Pages</a>. See the
                    <a href="http://docs.oracle.com/javaee/5/jstl/1.1/docs/tlddocs/">JSTL API</a>.
                </li>
          <li>Apache has a <a href="http://tomcat.apache.org/taglibs/standard/">JSTL Implementation</a>.</li>
            </ul>
            <subsection name="Velocity">
                <p>
                    <a href="http://velocity.apache.org/">Apache Velocity</a> implements
            a similar expression language.
                </p>
                <p>
            In particular the <a href="http://velocity.apache.org/engine/devel/user-guide.html#References">References</a>
            section of the User Guide has some good information on properties and method which correlate
            directly to JEXL.
                </p>
            </subsection>
        </section>

        <section name="Anyone Using It Yet?">
            <ul>
                <li>
                    <a href="https://commons.apache.org/configuration">Commons Configuration</a>
                </li>
                <li>
                    <a href="https://commons.apache.org/scxml">Commons SCXML</a>
                </li>
                <li>
                    <a href="https://commons.apache.org/jelly">Jelly</a>
                </li>
            </ul>
        </section>

    </body>
</document>

